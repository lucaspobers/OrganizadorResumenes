{% load static %}
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>
	<link rel="stylesheet" type="text/css" href='{% static "css/style-importado.css" %}'>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.8/ace.js"></script>
</head>
<body>
	<div class="header-container">
		<div class="header-button"><a href="/AppOrganizador/python/">Python</a></div>
		<div class="header-button"><a href="/AppOrganizador/django/">Django</a></div>
		<div class="header-button"><a href="/AppOrganizador/css/">CSS</a></div>
	</div>

	<div class="title-container">
		<h1 id="titulo1">Apuntes JavaScript</h1>
		<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Unofficial_JavaScript_logo_2.svg/1200px-Unofficial_JavaScript_logo_2.svg.png">
	</div>

	<div class="index-container">
		<ul class="index">
			<li><a href="#variables">Variables</a></li>
			<li><a href="#array">Array Asociativo</a></li>
			<li><a href="#for">Bucles</a></li>
			<li><a href="#label">Sentencia Label</a></li>
			<li><a href="#funciones">Funciones</a></li>		
			<li><a href="#return">Return</a></li>
			<li><a href="#parametros">Parametros</a></li>
			<li><a href="#flecha">Funciones Flecha</a></li>
			<li><a href="#poo">Programacion Orientada a Objetos</a></li>
			<li><a href="#herencia">Herencia</a></li>
			<li><a href="#estatico">Metodos Estaticos</a></li>
			<li><a href="#get">Getters y Setters</a></li>
			<li><a href="#cadena">Metodos de Cadena</a></li>
			<li><a href="#array">Metodos de Array</a></li>
			<li><a href="#filter">Filter y For Each</a></li>
			<li><a href="#math">Objeto Math</a></li>
			<li><a href="#consola">Consola</a></li>
			<li><a href="#dom">DOM</a></li>
			<li><a href="#atrglobal">Atributos Globales</a></li>
			<li><a href="#style">Atributo Style</a></li>
			<li><a href="#clases">Clases y Classlist</a></li>
			<li><a href="#omelem">Obtencion y Modificacion de Elementos</a></li>
			<li><a href="#creaelem">Creacion de Elementos</a></li>
			<li><a href="#docfrag">Create Document Fragment</a></li>
			<li><a href="#mchilds">Modificacion de Childs</a></li>
			<li><a href="#mc">Metodos de Childs</a></li>
			<li><a href="#pp">Propiedades de Parents</a></li>
			<li><a href="#ps">Propiedades de Siblings</a></li>
			<li><a href="#extras">Extras</a></li>
			<li><a href="#window">Introduccion a Window</a></li>
			<li><a href="#navegador">Herramientas de Desarrollo del Navegador</a></li>
			<li><a href="#eventos">Eventos</a></li>
			
		</ul>
	</div>

	<div class="codigo">
		<h2><a name="variables">Variables</a></h2>
		<p>Cuando declaramos una variable lo podemos hacer de varias maneras</p>
		<ul>
			<li>var - </li>
			<li>let - La variable sirve solo para un determinado bloque (scope)</li>
			<li>const - La variable siempre va a ser la misma, no pueden cambiar su valor</li>
		</ul>
		<div class="sintax">
		nombre = "Lucas Pobersnik";
		frase = `soy ${nombre} y estoy caminando`;			
		</div>
		<p>Con alt+96 pones esa especie de comillas que dice evita un monton de errores (backticks). Ademas te permite poner enters en el medio y lo sigue tomando</p>
		
	</div>
	<div class="codigo">
		<h2><a name="array">Array Asociativo</a></h2>
		<p></p>
		<div class="sintax">
		let	auto = {
			marca1: "fiat",
			marca2: "chevrolet",
			marca3: "ferrari",
		};

		document.write(auto["marca1"])			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="for">Bucles</a></h2>
		<h3>Do While</h3>
		<p>La diferencia con el while es que primero ejecuta (do) y despues pregunta (while)</p>
		<div class="sintax">
		contador = 0
		do{
			contador++;
			document.write(contador)

		};
		while (contador > 5)			
		</div>
		<h3>Bucle For</h3>
		<p>1° se declara la variable 'let i =0' <br>
		2° Se pone la condicion <br>
		3° Se pone si es en aumento o decremento 'i++'</p>
		<div class="sintax">
		for (let i = 0; < 6; i++) { // En este caso 'i' solo esta definida como variable en este bloque por el 'let'
			document.write(i + "&lt;br&gt;")
		}			
		</div>
		<h3>For In</h3>
		<p>El in nos devuelve la posicion en cada vuelta de bucle</p>
		<div class="sintax">
		let animales = ["gato", "perro", "foca"];

		for (animal in animales){
			document.write(animal + "&lt;br&gt;")

		};			
		</div>
		<h3>For Of</h3>
		<p>El of nos devuelve el contenido de la variable por cada vuelta de bucle</p>
		<div class="sintax">
		for (animal of animales){
			document.write(animal + "&lt;br&gt;")	
		};			
		</div>
		<p>La diferencia entre FOR IN y FOR OF. Ambos van a recorres el array, la diferencia es que en la variable 'animal uno va a guardar la posicion y el otro el valor.</p>

	</div>
	<div class="codigo">
		<h2><a name="label">Sentencia Label</a></h2>
		<p>Aca le pongo un 'nombre' al primer for para que cuando yo quiera terminarlo pueda hacerlo. Si no lo hago el break solamente aplicar al bucle en el que esta incluido</p>
		<div class="sintax">
		forLebeleado;
		for (let array in array1){
			if (array == 2){

				for (let array of array1){
					document.write(array + "&lt;br&gt;");
					break forLebeleado; // LABEL
				}

			} else {
				document.write(array2[array] + "&lt;br&gt;");
			}
		}			
		</div>
	</div>	
	<div class="codigo">
		<h2><a name="funciones">Funciones</a></h2>
		<p>Se le asigna a una palabra un bloque de codigo para no tener que volver a escribirlo si necesitas usarlo nuevamente</p>
		<div class="sintax">
		function saludar(){

			respuesta = prompt("¿Como fue tu dia?")
			if (respuesta == "bien"){
				alert("me alegro")
			} 
			else {
				alert("una pena")
			}

		}
		saludar() // Antes simplemente la declaro, si quiero que funcione la tengo que volver a escribir
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="return">Return</a></h2>
		<p>La funcion declarada no devuelve ningun tipo de dato. Si queremos que esto ocurra lo ponemos en el return</p>
		<div class="sintax">
		function saludar (){
			alert("hola");
			return "la funcion se ejecuto correctamente"
		}

		let saludo = saludar(); // Si no hubiera un return esta variable quedaria vacia porque 'saludar()' no le devuelve nada por si mismo

		document.write(saludo)
		</div>
	</div>
	<div class="codigo">
		<h2><a name="Parametros">Parametros</a></h2>
		<p>Si lo haces como el primer ejemplo, cada vez que quieras sumar algun numero que no sean esos vas a tener que escribir devuelta el codigo</p>
		<div class="sintax">
		function suma(){
			let numex = 32;
			let numej = 12;
			let res = numex+numej
			document.write(res);
		}

		suma();			
		</div>
		<p>Aca con los parametros, cuando necesites usar la suma pones los numeros al llamar a la funcion</p>
		<div class="sintax">
		function suma2(num1, num2){
			let res = num1+num2
			document.write(res);
			document.write("&lt;br&gt;");
		}

		suma2(12,32);
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="flecha">Funciones Flecha</a></h2>
		<p>Otra forma de declarar funciones (ahorra codigo)</p>
		<div class="sintax">
		const saludar = nombre=> document.write("lucas"); // Se tiene que poner el '=>'
		</div>
	</div>
	<div class="codigo">
		<h2><a name="poo">Programacion Orientada a Objetos</a></h2>
		<p></p>
		<div class="sintax">
		class animal{
			constructor(especie, edad, color){ //El CONSTRUCTOR es obligatorio cuando definimos una clase. Se definen las propiedades del objeto
				this.especie = especie;
				this.edad = edad;
				this.color = color;
				this.info = `Soy ${this.especie}, tengo ${this.edad} y soy de color ${this.color}`;
			}
			// METODO. Es basicamente lo mismo que una funcion pero dentro de una clase
			verInfo(){
				document.write(this.info + "&lt;br&gt;")
			}
		}			
		</div>
		<p>Nota al pie: Cuando usamos this adentro de una clase luego al querer usarlo fuera reemplazamos el this por el objeto (Ej. perro.especie)</p>
		<div class="sintax">
		const perro = new animal("perro", 5, "rojo"); // Con el new creamos un nuevo objeto dentro de la clase animal
		const gato = new animal("gato", 4, "azul") // Los objetos se definen con const
		const canario = new animal("canario", 10, "verde")

		// document.write(perro.info + "&lt;br&gt;")
		// document.write(gato.info + "&lt;br&gt;")
		// document.write(canario.info + "&lt;br&gt;")

		perro.verInfo();			
		</div>
	</div>
	<div class="codigo">
		<h2><a name="herencia">Herencia</a></h2>
		<p>Es tomar todo lo que puede hacer una clase pero ademas agregarle otras cosas</p>
		<div class="sintax">
		class animal{
			constructor(especie, edad, color){ 
				this.especie = especie;
				this.edad = edad;
				this.color = color;
				this.info = `Soy ${this.especie}, tengo ${this.edad} y soy de color ${this.color}`;
			}
			verInfo(){
				document.write(this.info + "&lt;br&gt;") //El metodo tambien se hereda en la clase de abajo
			}
		}

		class perro extends animal{
			constructor(especie, edad, color, raza){
				super(especie,edad, color); //Esto lo va a heredar de la clase animal, no es neceasrio que ponga los this
				this.raza = raza;
			}
			ladrar(){
				alert("wuf");
			}
		}

		const perrito = new perro("perro", 5, "rojo"); //Le cambio el nombre porque no puedo tener un objeto con el mismo nombre que la clase
		const gato = new animal("gato", 4, "azul")
		const canario = new animal("canario", 10, "verde")

		perrito.ladrar();
		//gato.ladrar(); no va a funcionar porque gato esta dentro de la clase animal, no dentro de la extension perro			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="estatico">Metodos Estaticos</a></h2>
		<p>Es un metodo en el cual yo no necesito que la clase se defina para ser creado</p>
		<div class="sintax">
		class animal{
			constructor(especie, edad, color){ 
				this.especie = especie;
				this.edad = edad;
				this.color = color;
				this.info = `Soy ${this.especie}, tengo ${this.edad} y soy de color ${this.color}`;
			}
			verInfo(){
				document.write(this.info + "&lt;br&gt;") 
			}
		}

		class perro extends animal{
			constructor(especie, edad, color, raza){
				super(especie,edad, color); 
				this.raza = raza;
			}
			static ladrar(){ //Puede ser un metodo estatico porque no estoy usando las propiedades
				alert("wuf");
			}
		}
		 
		const gato = new animal("gato", 4, "azul")
		const canario = new animal("canario", 10, "verde")

		perro.ladrar(); //A pesar de no haber creado el objeto, el metodo ladrar funciona			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="get">Getters y Setters</a></h2>
		<p>Con get obtenemos un valor, con set lo modificamos</p>
		<div class="sintax">
		class animal{
			constructor(especie, edad, color){ 
				this.especie = especie;
				this.edad = edad;
				this.color = color;
				this.info = `Soy ${this.especie}, tengo ${this.edad} y soy de color ${this.color}`;
			}
			verInfo(){
				document.write(this.info + "&lt;br&gt;") 
			}
		}

		class perro extends animal{
			constructor(especie, edad, color, raza){
				super(especie,edad, color); 
				this.raza = raza;
			}
			set setRaza(newName){ //Modificamos el valor de una propiedad de la clase utilizando un metodo que se convierte a propiedad
				this.raza = newName;
			}
				//GETTERS. Son para obtener informacion
			get getRaza(){
				return this.raza;
			}
		}

		const perrito = new perro ("perro", 5, "marron", "doberman") 
		const gato = new animal("gato", 4, "azul")
		const canario = new animal("canario", 10, "verde")

		perro.setRaza = "Pedro"
		document.write(perro.getRaza) 			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="cadena">Metodos de Cadena</a></h2>
		<ul>
			<li>concat() - junta dos o mas cadenas y retorna una nueva</li>
		</ul>
		<ul>
			<li>startsWith() - si una cadena con los caracteres devuelve true, sino devuelve false.</li>
			<li>endsWith() - si una cadena termina con los caracteres de otra cadena, devuelve true, sino false</li>
			<li>includes() - si una cadena puede encontrarse dentro de otra cadena, devuelve true, sino false</li>
			<li>indexOf() - devuelve el indice del primer caracter de la cadena, si no existe devuelve '-1'</li>
			<li>lastIndexOf() - devuelve el ultimo indice del primer caracter de la cadena, si no existe devuelte '-1'</li>
		</ul>
		<ul>
			<li>padStart() - Rellenar cadena al principio con los caracteres deseados. (Creo que no funciona)</li>
			<li>padEnd() - Rellenar cadena al final con los caracteres deseados. (Creo que no funciona)</li>
			<li>repeat() - Devuelve la misma cadena pero repetida la cantidad</li>
		</ul>
		<ul>
			<li>split() - Divide la cadena como le pidamos</li>
			<li>substring() - Nos retorna </li>
			<li>toLowerCase() - Convierte una cadena a minuscula</li>
			<li>toUpperCase() - Convierte una cadena a mayuscula</li>
			<li>toString() - metodo devuelve una cadena que representa al objeto especificado</li>
			<li>trim() - elimina los espacios en blanco al principio y al final de una cadena</li>
			<li>trimEnd() - elimina los espacios en blanco al principio y al final de una cadena</li>
			<li>trimStart() - elimina los espacios en blanco al comienzo de una cadena</li>
			<li>valueOf() - retorna el valor primitivo de un objeto string</li>
		</ul>
		<div class="sintax">
		let cadena = "cadena de prueba";
		let cadena2 = "cadena";

		resultado = cadena.startsWith(cadena2); //Si la cadena 1 empieza con la cadena 2
		resultado2 = cadena.includes(cadena2) // Si encuentra una cadena dentro de la otra
		resultado3 = cadena.indexOf(cadena2) // Igual que la anterior pero devuelve la posicion en la que se encuentra la primer letra
		// cadena.lastIndexOf() en vez de devolver el primero devuelve el ulitimo

		let cadena3 = "abc";

		resultado4 = cadena3.padStart(6, "a") //Rellena la cadena hasta tener 6 caracteres con 'a'
		//cadena3.padEnd lo suma al final y cadena3.repeat repite la cadena

		let cadena4 = "hola como estas"

		resultado5 = cadena4.split(" ") // Nos devuelve un array, la cadena se divide cada vez que se encuentra un espacio (puedo poner el caracter que yo quiera)
		resultado6 = cadena4.substring(0,2) // Crea string en las posiciones que indicamos


		document.write(resultado);			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="array">Metodos de Array</a></h2>
		<h4>Transformadores</h4>
		<ul>
			<li>pop() elimina el ultimo elemento de un array y lo devuelve</li>
			<li>shift() elimina el primer elemento de un array y lo devuelve</li>
			<li>push() agrega un elemento al array al final de la lista</li>
			<li>reverse() invierte el orden de los elementos de un array</li>
			<li>unshift() agrega uno o mas elementos al inicio del array, y devuelve la nueva longitud del array</li>
			<li>sort() ordena los elementos de un array localmente y lo devuelve ordenado (Ordena de manera alfabetica/ menor a mayor si son numeros)</li>
			<li>splice cambia el contenido de un array eliminando elementos existente y/o agregando nuevos elementos</li>
		</ul>
		<h4>Accesores</h4>
		<ul>
			<li>join() une todos los elementos de una matriz (u objeto similar) en una cadena y la devuelve | Convierte en string y permite poner un separador 'numeros.join(" - ")'</li>
			<li>slice() devuelve una parte de un array dentro de un nuevo array empezando por el inicio hasta el fin (fin no incluido)</li>
			<li>Metodos ya vistos en cadenas: toString(), indexOf()....</li>
		</ul>
		<h4>De Repeticion</h4>
		<ul>
			<li>filter() Crea un nuevo array con todos los elementos que cumplan la condicion (Sirve como un bucle)</li>
			<li>forEach() Ejecuta la funcion indicada una vez por cada elemento del array</li>
		</ul>
		<div class="sintax">
		let numeros = [1,2,3,4,5];

		document.write(numeros + "&lt;br&gt;")

		numeros.splice(1,3, 99 , 88) 
		// 1. Ponemos en la posicion la cual arrancamos (recorda que arranca en 0)
		// 2. Ponemos los elementos que deseamos eliminar
		// 3. Solo si quiere agregar nuevos elementos, los pongo despues de la tercera coma (Los pone en lugar de los que eliminamos)

		document.write(numeros);

		let prueba = [1,2,3,4,5,6]			
		</div>
	</div>
	<div class="codigo">
		<h2><a name="filter">Filter y For Each</a></h2>
		<p></p>
		<div class="sintax">
		let resultado = prueba.filter(prueba => prueba > 3)
		// Tengo que poner la 'condicion' como funcion flecha (en filter y forEach)

		document.write(resultado)
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="math">Objeto Math</a></h2>
		<p>Siempre se pone 'Math.xxxx()'</p>
		<h4>Metodos</h4>
		<ul>
			<li>sqrt() - Devuelve la raiz cuadrada positiva de un numero</li>
			<li>cbrt() - Devuelve la raiz cubica de un numero</li>
			<li>max() - Devuelve el mayor de cero o mas numeros</li>
			<li>min() - Devuelve el mas pequeño de cero o mas numeros</li>
			<li>random() - Devuelve un numero pseudo-aleatorio entre 0 y 1</li>
			<li>round() - Devuelve el valor de un numero redondeado al numero entero mas cercano</li>
			<li>fround() - Devuelve la represetacion flotante de precision simple mas cercana de un numero</li>
			<li>floor() - Devuelve el mayor entero menor que o igual a un numero | Redondea siempre para abajo, sin importar el decimal</li>
			<li>trunc() - Devuelve la parte entera del numero x, la eliminacion de los digitos fraccionarios | Solamente devuelve la parte entera, eliminando la decima</li>
		</ul>
		<h4>Propiedades</h4>
		<ul>
			<li>PI</li>
			<li>SQRT1_2</li>
			<li>SQRT2</li>
		</ul>
		<ul>
			<li>E</li>
			<li>LN2</li>
			<li>LN10</li>
			<li>LOG2E</li>
			<li>LOG10E</li>
		</ul>		
	</div>
	<div class="codigo">
		<h2><a name="consola">Consola</a></h2>
		<h4>Funciones de Registro</h4>
		<ul>
			<li>assert() - Aparece un mensaje de error en la consola si la afirmacion es falsa. Si la afirmacion es verdadera, no aparecera nada</li>
			<li>clear() - limpia la consola</li>
			<li>error() Muestra un mensaje de error en la Consola Web.</li>
			<li>info() - Emite un mensaje informativo a la Consola Web. En firefox y chrome, se muestra un pequeño icono "i" junto a estos elementos.</li>
			<li>log() - Muestra un mensaje en la consola web</li>
			<li>table() - Esta funcion toma un argumento obligatorio: data, que debe ser un array o un objeto, y un parametro adicional: columns y nos muestra una tabla en consola</li>
			<li>warn() - Imprime un mensaje de adverencia en la Consola Web</li>
			<li>dir() - Despliega una lista interactiva de las propiedades del objeto JavaScript especificado</li>
		</ul>
		<h4>Funciones de Conteo</h4>
		<ul>
			<li>count() - Registra el numero de veces que se llama a count(). Esta funcion toma como argumento opcional una etiqueta.</li>
			<li>countReset() - Resetea el contador count</li>
		</ul>
		<h4>Funciones de Agrupacion</h4>
		<ul>
			<li>group() - Crea un nuevo grupo en linea en el registro de la consola</li>
			<li>groupEnd() - Remueve ""</li>
			<li>groupCollapsed() - Crea un grupo en linea pero contraido, el usuario debe expandirlo para verlo</li>
		</ul>
		<h4>Funciones de Temporizacion</h4>
		<ul>
			<li>time() - Inicia un temporizador</li>
			<li>timeEnd() - Registra el valor actual de un temporizado</li>
			<li>timeLog() - Detiene el temporizador.</li>
		</ul>
	</div>
	<div class="codigo">
		<h2><a name="dom">DOM</a></h2>
		<h4>Nodo</h4>
		<p>Un nodo en el DOM es cualquier etiqueta del cuerpo, como un parrafo, el mismo body o incluso las etiquetas de una lista.</p>
		<ul>
			<li>Document: El nodo document es el nodo raiz, a partir del cual derivan el resto de nodos</li>
			<li>Element: Nodos definidos por etiquetas HTML</li>
			<li>Text: El texto dentro de un nodo element se considera un nuevo nodo hijo de tipo text</li>
			<li>Attribute: Los atributos de las etiquetas definen nodos, (en JavaScript no los veremos como nodos sino como informacion asociada al nodo de tipo element)</li>
			<li>Comentarios y otros: Los comentarios y otros elementos como las declaraciones doctype en cabecera de los documentos HTML generan nodos.</li>
		</ul>
		<h4>Document</h4>
		<p>Metodos de seleccion de elementos (a todos se le pone previamente document.getElementById()</p>
		<ul>
			<li>getElementById() - Selecciona un elemento por ID</li>
			<li>getElementByTagName() - Selecciona todos los elementos que coincidad con el nombre de la etiqueta especificada</li>
			<li>querySelector() - Devuelve el primer elemento que coincida con el grupo especificado de selectores</li>
			<li>querySelectorAll() - Devuelve todos los elementos que coincidan con el grupo especificado de selectores.</li>
		</ul>
		<div class="sintax">
		parrafo = document.getElementById('parrafo') //Guardo en una variable lo que tengo en el HTML bajo el ID parrafo
		document.write(parrafo) // Esta es la manera que tenemos de seleccionar un objeto entero, no necesariamente me va a guardar un string

		document.getElementsByTagName('p') // Este me devuelve una 'coleccion' porque devuelve todos los elementos P, el id en cambio es unico

		document.querySelector(".parrafo") // Selecciono una clase
		document.querySelector("#parrafo") // Podemos usar esto para seleccionar por ID pero lo mas optimo es usar la otra opcion

		queryAll = document.querySelectorAll(".parrafo") // Me devuelve TODOS los que sean clase parrafo como una 'node list'
		document.write(queryAll[1]) // Los puedo seleccionar por indice			
		</div>
		<h4>Metodos para Definir, Obtener y Eliminar valores de atributos</h4>
		<ul>
			<li>setAttribute() - Modifica el valor de un atributo</li>
			<li>getAttribute() - Obtiene el valor de un atributo</li>
			<li>removeAttribute() - Remueve el valor de un atributo</li>
		</ul>
		<div class="sintax">
		const rangoEtario = document.querySelector(".rangoEtario");

		rangoEtario.setAttribute("type","text") // En el primer atributo ponemos que queremos modificar y en el segundo lo nuevo
		// No solo modifica los atributos sino que tambien los crea (En caso de que no lo tenga)

		valorDelAtributo = rangoEtario.getAttribute("type") //Obtiene el atributo, en este caso text

		document.write(valorDelAtributo)			
		</div>
	</div>
	<div class="codigo">
		<h2><a name="atrglobal">Atributos Globales</a></h2>
		<ul>
			<li>class - Lista de clases del elemento separadas por espacios</li>
			<li>contenteditable - indica si el elemento puede ser modificable por el usuario (bool)</li>
			<li>dir - indica la direccionalidad del texto</li>
			<li>hidden - indica si el elemento aun no es, o ya no es relevante</li>
			<li>id - define un identificador unico</li>
			<li>style - contiene declaraciones de estilo CSS para ser aplicadas al elemento</li>
			<li>tabindex - indica si el elemento puede obtener un focus de input</li>
			<li>title - contiene un texto con informacion relacionada al elemento al que pertenece.</li>
		</ul>
		<h2>Atributos de Inputs</h2>
		<ul>
			<li>className - Nos dice el nombre de la clase</li>
			<li>value -Nos dice lo que esta adentro del input</li>
			<li>type - input.type ="number" // Lo modificamos directamente</li>
			<li>accept - Se usa para los input file (subir fotos) | Ej. input.accept = "image/png" solo acepta dicho formato</li>
			<li>minlenght - Minima cantidad de caracteres que debe tener un input</li>
			<li>placeholder - input.placeholder = "Aca va el texto que aparece dentro del recuadro de input por defecto"</li>
			<li>required -</li>
			<li>form - Permite ejecutar un input dentro de un form</li>
			<div class="sintax">
				&lt;form&gt;
					&lt;input type="text" class="input-normal"&gt;
					&lt;input type="submit"&gt; &lt;!-- Boton enviar --&gt;
				&lt;/form&gt;				
			</div>
		</ul>
		
	</div>
	<div class="codigo">
		<h2><a name="style">Atributo Style</a></h2>
		<p>Podemos modificar el CSS desde JavaScript</p>
		<div class="sintax">
		const titulo = document.querySelector(".titulo")

		titulo.style.color = "red"
		titulo.style.backgroundColor = "blue"
		titulo.style.padding = "30px"			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="clases">Clases y Classlits</a></h2>
		<ul>
			<li>add() - Añade una clase</li>
			<li>remove() - Remueve una clase</li>
			<li>item() - Devuelve la clase del indice especificado</li>
			<li>contains() - Verifica si ese elemento posee o no, la clase especificada</li>
			<li>replace() - Reemplaza una clase por otra | titulo.classList.replace("grande", "chico") - Reemplaza la clase grande por chico</li>
			<li>toogle() - Si no tiene la calse especificada, la agrega, si ya la tiene, la elimina</li>
		</ul>
		<div class="sintax">
		const titulo = document.querySelector(".titulo")

		titulo.classList.add("grande")			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="omelem">Obtencion y Modificacion de Elementos</a></h2>
		<ul>
			<li>textContent - devuelve el texto de cualquier nodo.</li>
			<li>innerHTML - devuelve el contenido html de un elemento</li>
			<li>outerHTML - devuelve el codigo HTML completo del elemento</li>
		</ul>
		<div class="sintax">
		const titulo = document.querySelector(".titulo")

		let resultado = titulo.textContent // Devuelve unicamente el texto, es decir, si en el HTML tenia negrita no se va a ver
		let resultado2 = titulo.innerHTML // Devuelve todo el contenido HTML
		let resultad3 = titulo.outerHTML // Devuelve el codigo HTML tambien incluyendo las etiquetas

		alert(resultado)
		alert(resultado2)
		alert(resultado3)			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="creaelem">Creacion de Elementos</a></h2>
		<ul>
			<li>createElements()</li>
			<li>createTextNode()</li>
			<li>appendChild()</li>
			<li>createDocumentFragment() - Sirve para crear muchas etiquetas de un sauqe (Por ejemplo en una lista)</li>
		</ul>
		<div class="sintax">
		const contenedor = document.querySelector(".contenedor")


		const item = document.createElement("LI") // Creamos una lista, si o si tiene que ser en mayuscula

		const textoDelItem = document.createTextNode("Ese es un item de la lista")
		item.appendChild(textoDelItem) // Este lo agrega dentro de la etiqueta 'li' creada anteriormente


		item.innerHTML = "Este es otro item de la lista" // Otra manera de agregar texto dentro de la etiqueta 'li'
		contenedor.appendChild(item) // Entiendo que es otra manera de agregar el li			
		</div>
	</div>
	<div class="codigo">
		<h2><a name="docfrag">Create Document Fragment</a></h2>
		<p></p>
		<div class="sintax">
		const contenedor = document.querySelector(".contenedor")

		const fragmento = document.createDocumentFragment()

		for  (i = 0; i < 20; i++) {
			const item = document.createElement("LI")
			item.innerHTML = "Este es un item de la lista"
			fragmento.appendChild(item)
		}

		contenedor.appendChild(fragmento)			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="mchilds">Obtencion y Modificacion de Childs</a></h2>
		<ul>
			<li>fistchild</li>
			<li>lastchild</li>
			<li>firstElementChild - Devuelve el primer ELEMENTO (usar este no los anteriores)</li>
			<li>lastElementChild</li>
			<li>childNodes - Devuelve TODOS los nodos hijos (incluidos los text)</li>
			<li>children - Devuelve todos los ELEMENTOS hijos (no incluidos los text)</li>
		</ul>
		<div class="sintax">
		const contenedor = document.querySelector(".contenedor")

		const primerHijo = contenedor.firstChild; // Muestra el primer hijo de 'contenedor'
		const ultimoHijo = contenedor.lastChild

		// Como tiene adelante un espacio va a mostrar '#text'

		const primerElementoHijo = contenedor.firstElementChild; // A diferencia de los anteriores NO toma en cuenta los espacios

		const hijos = contenedor.children;
		for (hijo of hijos){ // PARA RECORRERLO (no se puede con un for each como el resto)
			console.log(hijo)
		}			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="mc">Metodos de Childs</a></h2>
		<ul>
			<li>appendChild()</li>
			<li>replaceChild()</li>
			<li>removeChild()</li>
			<li>hasChildNodes() - Verifica si el elemento tiene hijos y devuelve un booleano</li>
		</ul>
		<div class="sintax">
		const contenedor = document.querySelector(".contenedor")

		const parrafo = document.createElement("P").innerHTML = "Parrafo";
		const h2_nuevo = document.createElement("H2")
		h2_nuevo.innerHTML = "Titulo"

		h2_antiguo = document.querySelector(".h2")

		contenedor.replaceChild(h2_nuevo, h2_antiguo) // Primero va el elemento nuevo y despues el antiguo

		// contenedor.removeChild(h2_antiguo)

		respuesta = contenedor.hasChildNodes() // Verifica si el elemento tiene hijos y devuelve un booleano 			
		</div>	
	</div>	
	<div class="codigo">
		<h2><a name="pp">Propiedades de Parents</a></h2>
		<ul>
			<li>parentElement - Muestra el elemento padre (Se usa este)</li>
			<li>parentNode</li>
		</ul>
		<div class="sintax">
		console.log(contenedor.parentElement)			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="ps">Propiedades de Siblings</a></h2>
		<p>Es decir los que estan en el mismo 'rango'</p>
		<ul>
			<li>nextSibling</li>
			<li>previousSibling</li>
			<li>nextElementSibling - Solo muestra el elemento</li>
			<li>previousElementSibling</li>
		</ul>
		<div class="sintax">
		console.log(h2_antiguo.nextElementSibling)			
		</div>
		
	</div>
	<div class="codigo">
		<h2><a name="extras">Extras</a></h2>
		<ul>
			<li>closest() - Muestra el elemento ascendente mas cercano de nuestro selector</li>
		</ul>
		<div class="sintax">
		const div = document.querySelector(".div-3");

		console.log(div.closest(".div"))			
		</div>		
	</div>
	<div class="codigo">
		<h2><a name="window">Introduccion a Window</a></h2>
		<p>Es muy importante ya que es el objeto con la mas alta jerarquia de JS, lo que significa que hasta el DOM depende de Window. Su sintaxis es:</p>
		<div class="sintax">
		window.open("https://youtube.com")	
		</div>
		<ul>
			<li>Hereda las propiedades de EventTarget</li>
			<li>open() - Carga un recurso en el contexto de un nuevo navegador o uno que ya existe. En el ejemplo anterior, abre una ventana emergente</li>
			<li>close() - Cierra la ventana actual o la ventana que se llamo</li>
			<li>closed - Indica si la ventana referenciada esta cerrada o no. Devuelve un booleano.</li>
			<li>stop() - Simula que nosotros apretaramos el boton de 'cancelar carga' que tienen los navegadores.</li>
			<li>alert() - Muestra un cuadro de alerta con el contenido especificado y un boton aceptar</li>
			<li>print() - Abre el cuadro de dialogo imprimir para imprimir el documento actual</li>
			<li>prompt() - Abre un cuadro de dialogo con una especie de input, que lo que ingrese el usuario lo devuelve como un string</li>
			<li>confirm() - Abre un cuadro de dialogo con las opciones 'aceptar' y 'cancelar'. Devuelve un booleano</li>
			<li></li>
		</ul>
		<ul>
			<li>screen - Si nosotros guardamos en una variable window.screen nos va a devolver el objeto pantalla y a traves de la consola podemos ver sus propiedades</li>
			<li>screenLeft - Devuelve la distancia horizontal entre el borde izquierdo del navegador y el border izquierdo de la pantalla. Ovbiamente esto se va a modificar cuando nostros minimizemos la ventana o la corrarmos de posicion.</li>
			<li>screenTop - Devuelve la distancia vertical entre el borde superior del navegador y el border superior de la pantalla</li>
			<li>scrollX - Devuleve el numero de pixeles que el documento se desplaza horizontalmente. Si tenemos la barra en la mitad de la pantalla, devuelve el numero de pixeles desplazados</li>
			<li>scrollY - Devuleve el numero de pixeles que el documento se desplaza verticalmente</li>
			<li>scroll() - desplaza la ventana a un lugar particular del documento. (con options y con posiciones)(X Y)</li>
		</ul>
		<ul>
			<li>resizeBy() - cambia el tamaño de la ventana actual en una cantidad especifica</li>
			<li>resizeTo() - redimensiona dinamicamente la vetana</li>
			<li>moveBy() - Mueve la ventana en una ubicacion relativa</li>
			<li>moveTo() - Mueve la ventana en una ubicacion absoluta</li>
		</ul>
		<ul>
			<li>Objetos Barprop - Casi ni se ven. Son objeto los cuales podemos acceder a su visibilidad</li>
			<ul>
				<li>locationbar</li>
				<li>menubar</li>
				<li>personalbar</li>
				<li>scrollbars</li>
				<li>statusbar</li>
				<li>toolbar</li>
			</ul>
		</ul>
		<h3>Location</h2>
			<ul>
				<li>window.location.href - Me devuelve donde esta localizado mi archivo (https://youtube.com/channel/OD89TESA)</li>
				<li>window.location.hostname - Devuelve el nombre del dominio del servidor web (www.youtube.com)</li>
				<li>window.location.pathname - Nos devuelve donde estamos desde el dominio (todo lo que sigue despues despues de la barra)</li>
				<li>window.location.protocol - Devuelve el protocolo (https o http)</li>
				<li>window.location.assign() - Carga un nuevo documento </li>
			</ul>
	</div>
	<div class="codigo">
		<h2><a name="navegador">Herramientas de Desarrollo del Navegador</a></h2>
		<h3>Pestaña Sources</h3>
		<p>La pestaña resources nos permite trabajar con todos los archivos activos en la pagina, con la particularidad de que al tocar CTRL + S los cambios se guardan</p>
		<h4>Snippets</h4>
		<p>Dentro de esta pestaña nos vamos a encontrar con los snippets que son fragmentos de codigo que podemos ejecutar cuando nosotros querramos</p>
		<p>Cuando ya tengamos un snippet guardado con CTRL + '+' se ejecuta</p>

		<h3>Pestaña Network</h3>
		<p>Para que nos muestre algo tenemos que refrescar la pagina con esta pestaña abierta. Nos muestra todos los archivos que se 'inicializaron', de que archivo nacen y hasta en que linea.</p>
		<p>Esta pestaña sirve mucho para optimizar</p>

		<h3>Pestaña Timeline/ Performance</h3>
		<p>En ella podemos realizar 'grabaciones' de lo que esta sucediendo en la pagina para analizar el consumo de recursos</p>
	</div>
	<div class="codigo">
		<h2><a name="eventos">Eventos</a></h2>
		<p>Podemos considerar un evento a cualquier accion que se realice dentro de la pagina. Ahora bien, estos eventos por si solos no me sirven de nada, para que me sean utiles tengo que asociar una porcion de codigo a un elemento que esta pasando por un proceso de evento.</p>
		<h3>Event Handlers</h3>
		<p>Para asociarlos a un codigo se utiliza algo llamado 'Event Handler'</p>
		<div class="sintax">
		const button = document.querySelector(".button");

		button.onclick = ()=>{
			alert("hola")
		}			
		</div>
		<p>En este ejemplo, se nombra un boton con la clase 'button', se lo registra a un variable y se da la orden de que cuando se haga click salte un alert.</p>
		<h3>Event Listeners</h3>
		<p>Ahora dijo que esta manera de trabajar con eventos no es la mas recomendable ya que hay veces que los 'Event Handlers' no funciona, asi que recomienda trabajar con 'Event Listeners' por lo que el codigo quedaria de la siguiente manera</p>
		<div class="sintax">
		const button = document.querySelector(".button");

		button.addEventListener("click", ()=>{
			alert("pedro");
		})	
		</div>
		<p>La unica manera de trabajar con Event Listeners y funciones flecha es esta, despues si no queremos que quede integrada lo hacemos con las funciones normales</p>
		<div class="sintax">
		const button = document.querySelector(".button");

		button.addEventListener("click", saludar)

		function saludar(){
			alert("hola");
			button.removeEventListener("click", saludar)
		}			
		</div>
		<h3>Objeto Evento</h3>
		<p>Para acceder al objeto evento</p>
		<div class="sintax">
		const button = document.querySelector(".button");

		button.addEventListener("click",(e)=>{
			console.log(e)
		})			
		</div>
		<p>Para acceder al objeto que desencadena este evento se pone 'e.target' dentro del console.log</p>
		<h3>Flujo de Eventos o 'Event Flow'</h3>
		<p>Con esto nos referimos al orden en que se van a ejecutar los eventos. Tenemos dos tipos el 'Event Bubbling' y el 'Event Capturing</p>
		<p>Por defecto se van a ejecutar primero los mas especificos y luego los menos (Event Bubbling), para cambiarlo podemos utilizar el siguiente codigo</p>
		<div class="sintax">
		button.addEventListener("click",(e)=>{
			alert("di click en el contenedor")
		}, true)
		</div>
		<p>Cuando hay varios eventos que se superponen, el que tiene true se ejecuta primero</p>
		<h4>Stop Propagation</h4>
		<p>Le damos la indicacion que en caso que ya se haya ejecutado un evento, el resto de eventos asociados no se ejecute.</p>
		<div class="sintax">
		button.addEventListener("click",(e)=>{
			alert("di click en el boton")
			e.stopPropagation()
		})			
		</div>
		<h3>Eventos de Mouse</h3>
		<ul>
			<li>click - ocurre con un click (se considera click apretar y soltar)</li>
			<li>dblclick - ocurre con un doble click</li>
			<li>mouseover - ocurre cuando el puntero se mueve sobre un elemento o sobre uno de sus hijos</li>
			<li>mouseout - ocurre cuando se mueve el puntero fuera de un elemento o de sus elementos secundarios</li>
		</ul>
		<ul>
			<li>contextmenu - ocurre con un click en el boton derecho de un elemento para abrir el menu contxtual</li>
			<li>mouseleave - ocurre cuando el puntero se mueva fuera de un elemento (la diferencia es que este no se deja de ejecutar nunca mientras este activo)</li>
			<li>mousedown - ocurre cuando un usuario aprieta un boton del mouse sobre un elemento</li>
			<li>mouseup - ocurre cuando un usuario suelta un boton del mouse sobre un elemento</li>
			<li>mousemove - ocurre cuando el puntero se mueve mientras esta sobre un elemento</li>
		</ul>
		<h3>Eventos de Teclado</h3>
		<ul>
			<li>keydown - ocurre cuando una tecla se deja de presionar</li>
			<li>keypress - ocurre cuando una tecla se presiona y suelta en un elemento</li>
			<li>keyup - ocurre cuando una tecla se suelta</li>
		</ul>
		<h3>Eventos de la Interfaz</h3>
		<ul>
			<li>error - ocurre cuando sucede un error durante la carga de un archivo multimedia</li>
			<li>load - ocurre cuando un objeto se ha cargado (puede ser todo el sitio)</li>
			<li>beforeunload - ocurre antes de que el documento este a punto de descargarse (antes de irte del sitio)</li>
			<li>unload - ocurre una vez que se ha descargada una pagina (cuando ya te fuiste del sitio)</li>
			<li>resize - ocurre cuando se cambia el tamaño de la vista del documento</li>
			<li>scroll - ocurre cuando se desplaza la barra de desplazamiento de un elemento</li>
			<li>select - ocurre despues de que el usuario selccion algun texto de &lt;input&gt; o &lt;textarea&gt;. Es muy util ya que podemos por ejemplo, ver en que posicion el usuario comenzo y dejo de seleccionar.</li>
		</ul>
		<div class="sintax">
		const input = document.querySelector(".input-prueba")

		input.addEventListener("select", (e)=>{
			console.log(e.target.selectionStart)
		})			
		</div>
		<h3>Temporizadores</h3>
		<p>setTimeout() - Le pasamos como parametro los milisegundos que van a pasar hasta que la accion se ejecute. (con clearTimeout() lo detenemos)</p>
		<div class="sintax">
		setTimeout(()=>{
			document.write("hola")
		},2000) 
		</div>
		<p>setInterval() - Hace lo mismo que la anterior pero se sigue ejecutando constantemente. (Lo podemos parar con clearInterval())</p>
	</div>
		























</body>
<script type="text/javascript" src='{% static "js/estilos.js" %}'></script>
</html>